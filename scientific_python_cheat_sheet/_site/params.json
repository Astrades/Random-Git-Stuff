{
  "name": "Scientific python cheat sheet",
  "tagline": "simple overview of python, numpy, scipy, matplotlib functions that are useful for scientific work",
  "body": "Scientific Python Cheatsheet\r\n============================\r\n\r\n<!-- markdown-toc start - Don't edit this section. Run M-x markdown-toc-generate-toc again -->\r\n**Table of Contents**\r\n\r\n- [Scientific Python Cheatsheet](#scientific-python-cheatsheet)\r\n    - [Pure Python](#pure-python)\r\n        - [Types](#types)\r\n        - [Lists](#lists)\r\n        - [Dictionaries](#dictionaries)\r\n        - [Strings](#strings)\r\n        - [Operators](#operators)\r\n        - [Control Flow](#control-flow)\r\n            - [if/elif/else](#ifelifelse)\r\n            - [for](#for)\r\n            - [while](#while)\r\n            - [break](#break)\r\n            - [continue](#continue)\r\n        - [Functions, Classes, Generators, Decorators](#functions-classes-generators-decorators)\r\n            - [Function](#function)\r\n            - [Class](#class)\r\n            - [Generators](#generators)\r\n            - [Decorators](#decorators)\r\n    - [NumPy](#numpy)\r\n        - [array initialization](#array-initialization)\r\n        - [reading/ writing files](#reading-writing-files)\r\n        - [array properties and operations](#array-properties-and-operations)\r\n        - [indexing](#indexing)\r\n        - [boolean arrays](#boolean-arrays)\r\n        - [elementwise operations and math functions](#elementwise-operations-and-math-functions)\r\n        - [inner / outer products](#inner--outer-products)\r\n        - [interpolation, integration](#interpolation-integration)\r\n        - [fft](#fft)\r\n        - [rounding](#rounding)\r\n        - [random variables](#random-variables)\r\n    - [Matplotlib](#matplotlib)\r\n        - [figures and axes](#figures-and-axes)\r\n        - [figures and axes properties](#figures-and-axes-properties)\r\n        - [plotting routines](#plotting-routines)\r\n\r\n<!-- markdown-toc end -->\r\n\r\nPure Python\r\n-----------\r\n\r\n### Types\r\n```python\r\na = 2           # integer\r\nb = 5.0         # float\r\nc = 8.3e5       # exponential\r\nd = 1.5 + 0.5j  # complex\r\ne = 3 > 4       # boolean\r\nf = 'word'      # string\r\n```\r\n\r\n### Lists\r\n\r\n```python\r\na = ['red', 'blue', 'green']      # manually initialization\r\nb = range(5)                      # initialization through a function\r\nc = [nu**2 for nu in b]           # initialize through list comprehension\r\nd = [nu**2 for nu in b if b < 3]  # list comprehension withcondition\r\ne = c[0]                          # access element\r\nf = e[1: 2]                       # access a slice of the list\r\ng = ['re', 'bl'] + ['gr']         # list concatenation\r\nh = ['re'] * 5                    # repeat a list\r\n['re', 'bl'].index('re')          # returns index of 're'\r\n're' in ['re', 'bl']              # true if 're' in list\r\nsorted([3, 2, 1])                 # returns sorted list\r\nz = ['red'] + ['green', 'blue']   # list concatenation\r\n```\r\n\r\n### Dictionaries\r\n\r\n```python\r\na = {'red': 'rouge', 'blue': 'bleu', 'green': 'vert'}  # dictionary\r\nb = a['red']                                           # translate item\r\nc = [value for key, value in b.items()]                # loop through contents\r\nd = a.get('yellow', 'no translation found')            # return default\r\n```\r\n\r\n### Strings\r\n\r\n```python\r\na = 'red'                      # assignment\r\nchar = a[2]                    # access individual characters\r\n'red ' + 'blue'                # string concatenation\r\n'1, 2, three'.split(',')       # split string into list\r\n'.'.join(['1', '2', 'three'])  # concatenate list into string\r\n```\r\n\r\n### Operators\r\n\r\n```python\r\na = 2             # assignment\r\na += 1 (*=, /=)   # change and assign\r\n3 + 2             # addition\r\n3 / 2             # integer division (python2) or float division (python3)\r\n3 // 2            # integer division\r\n3 * 2             # multiplication\r\n3 ** 2            # exponent\r\n3 % 2             # remainder\r\nabs()             # absolute value\r\n1 == 1            # equal\r\n2 > 1             # larger\r\n2 < 1             # smaller\r\n1 != 2            # not equal\r\n1 != 2 and 2 < 3  # logical AND\r\n1 != 2 or 2 < 3   # logical OR\r\nnot 1 == 2        # logical NOT\r\na in b            # test if a is in b\r\na is b            # test if objects point to the same memory (id)\r\n```\r\n\r\n### Control Flow\r\n\r\n#### if/elif/else\r\n```python\r\na, b = 1, 2\r\nif a + b == 3:\r\n    print 'True'\r\nelif a + b == 1:\r\n    print 'False'\r\nelse:\r\n    print '?'\r\n```\r\n\r\n#### for\r\n\r\n```python\r\na = ['red', 'blue',\r\n     'green']\r\nfor color in a:\r\n    print color\r\n```\r\n\r\n#### while\r\n\r\n```python\r\nnumber = 1\r\nwhile number < 10:\r\n    print number\r\n    number += 1\r\n```\r\n\r\n#### break\r\n```python\r\nnumber = 1\r\nwhile True:\r\n    print number\r\n    number += 1\r\n    if number > 10:\r\n        break\r\n```\r\n\r\n#### continue\r\n\r\n```python\r\nfor i in range(20):\r\n    if i % 2 == 0:\r\n        continue\r\n    print i\r\n```\r\n\r\n### Functions, Classes, Generators, Decorators\r\n\r\n#### Function\r\n```python\r\ndef myfunc(a1, a2):\r\n    return x\r\n\r\nx = my_function(a1,a2)\r\n```\r\n\r\n#### Class\r\n```python\r\nclass Point(object):\r\n    def __init__(self, x):\r\n        self.x = x\r\n    def __call__(self):\r\n        print self.x\r\n\r\nx = Point(3)\r\n```\r\n\r\n#### Generators\r\n```python\r\ndef firstn(n):\r\n    num = 0\r\n    while num < n:\r\n        yield num\r\n        num += 1\r\n\r\nx = [for i in firstn(10)]\r\n```\r\n\r\n#### Decorators\r\n```python\r\nclass myDecorator(object):\r\n    def __init__(self, f):\r\n        self.f = f\r\n    def __call__(self):\r\n        print \"call\"\r\n        self.f()\r\n\r\n@myDecorator\r\ndef my_funct():\r\n    print 'func'\r\n\r\nmy_func()\r\n```\r\n\r\n## NumPy\r\n\r\n### array initialization\r\n\r\n```python\r\nnp.array([2, 3, 4])             # direct initialization\r\nnp.empty(20, dtype=np.float32)  # single precision array with 20 entries\r\nnp.zeros(200)                   # initialize 200 zeros\r\nnp.ones((3,3), dtype=np.int32)  # 3 x 3 integer matrix with ones\r\nnp.eye(200)                     # ones on the diagonal\r\nnp.zeros_like(a)                # returns array with zeros and the shape of a\r\nnp.linspace(0., 10., 100)       # 100 points from 0 to 10\r\nnp.arange(0, 100, 2)            # points from 0 to <100 with step width 2\r\nnp.logspace(-5, 2, 100)         # 100 log-spaced points between 1e-5 and 1e2\r\nnp.copy(a)                      # copy array to new memory\r\n```\r\n\r\n### reading/ writing files\r\n\r\n```python\r\nnp.fromfile(fname/object, dtype=np.float32, count=5)  # read binary data from file\r\nnp.loadtxt(fname/object, skiprows=2, delimiter=',')   # read ascii data from file\r\n```\r\n\r\n### array properties and operations\r\n\r\n```python\r\na.shape                # a tuple with the lengths of each axis\r\nlen(a)                 # length of axis 0\r\na.ndim                 # number of dimensions (axes)\r\na.sort(axis=1)         # sort array along axis\r\na.flatten()            # collapse array to one dimension\r\na.conj()               # return complex conjugate\r\na.astype(np.int16)     # cast to integer\r\nnp.argmax(a, axis=2)   # return index of maximum along a given axis\r\nnp.cumsum(a)           # return cumulative sum\r\nnp.any(a)              # True if any element is True\r\nnp.all(a)              # True if all elements are True\r\nnp.argsort(a, axis=1)  # return sorted index array along axis\r\n```\r\n\r\n### indexing\r\n\r\n```python\r\na = np.arange(100)          # initialization with 0 - 99\r\na[: 3] = 0                  # set the first three indices to zero\r\na[1: 5] = 1                 # set indices 1-4 to 1\r\na[start:stop:step]          # general form of indexing/slicing\r\na[None, :]                  # transform to column vector\r\na[[1, 1, 3, 8]]             # return array with values of the indices\r\na = a.reshape(10, 10)       # transform to 10 x 10 matrix\r\na.T                         # return transposed view\r\nnp.transpose(a, (2, 1, 0))  # transpose array to new axis order\r\na[a < 2]                    # returns array that fulfills elementwise condition\r\n```\r\n\r\n### boolean arrays\r\n\r\n```python\r\na < 2                          # returns array with boolean values\r\nnp.logical_and(a < 2, b > 10)  # elementwise logical and\r\nnp.logical_or(a < 2, b > 10)   # elementwise logical or\r\n~a                             # invert boolean array\r\nnp.invert(a)                   # invert boolean array\r\n```\r\n\r\n### elementwise operations and math functions\r\n\r\n```python\r\na * 5              # multiplication with scalar\r\na + 5              # addition with scalar\r\na + b              # addition with array b\r\na / b              # division with b (np.NaN for division by zero)\r\nnp.exp(a)          # exponential (complex and real)\r\nnp.sin(a)          # sine\r\nnp.cos(a)          # cosine\r\nnp.arctan2(y,x)    # arctan(y/x)\r\nnp.arcsin(x)       # arcsin\r\nnp.radians(a)      # degrees to radians\r\nnp.degrees(a)      # radians to degrees\r\nnp.var(a)          # variance of array\r\nnp.std(a, axis=1)  # standard deviation\r\n```\r\n\r\n### inner / outer products\r\n\r\n```python\r\nnp.dot(a, b)                        # inner matrix product: a_mi b_in\r\nnp.einsum('ijkl,klmn->ijmn', a, b)  # einstein summation convention\r\nnp.sum(a, axis=1)                   # sum over axis 1\r\nnp.abs(a)                           # return array with absolute values\r\na[None, :] + b[:, None]             # outer sum\r\na[None, :] * b[None, :]             # outer product\r\nnp.outer(a, b)                      # outer product\r\nnp.sum(a * a.T)                     # matrix norm\r\n```\r\n\r\n### interpolation, integration\r\n\r\n```python\r\nnp.trapz(y, x=x, axis=1)  # integrate along axis 1\r\nnp.interp(x, xp, yp)      # interpolate function xp, yp at points x\r\n```\r\n\r\n### fft\r\n\r\n```python\r\nnp.fft.fft(y)             # complex fourier transform of y\r\nnp.fft.fftfreqs(len(y))   # fft frequencies for a given length\r\nnp.fft.fftshift(freqs)    # shifts zero frequency to the middle\r\nnp.fft.rfft(y)            # real fourier transform of y\r\nnp.fft.rfftfreqs(len(y))  # real fft frequencies for a given length\r\n```\r\n\r\n### rounding\r\n\r\n```python\r\nnp.ceil(a)   # rounds to nearest upper int\r\nnp.floor(a)  # rounds to nearest lower int\r\nnp.round(a)  # rounds to neares int\r\n```\r\n\r\n### random variables\r\n\r\n```python\r\nnp.random.normal(loc=0, scale=2, size=100)  # 100 normal distributed random numbers\r\nnp.random.seed(23032)                       # resets the seed value\r\nnp.random.rand(200)                         # 200 random numbers in [0, 1)\r\nnp.random.uniform(1, 30, 200)               # 200 random numbers in [1, 30)\r\nnp.random.random_integers(1, 15, 300)       # 300 random integers between [1, 15]\r\n```\r\n\r\n## Matplotlib\r\n\r\n### figures and axes\r\n\r\n```python\r\nfig = plt.figure(figsize=(5, 2), facecolor='black')  # initialize figure\r\nax = fig.add_subplot(3, 2, 2)                        # add second subplot in a 3 x 2 grid\r\nfig, axes = plt.subplots(5, 2, figsize=(5, 5))       # return fig and array of axes in a 5 x 2 grid\r\nax = fig.add_axes([left, bottom, width, height])     # manually add axes at a certain position\r\n```\r\n\r\n### figures and axes properties\r\n\r\n```python\r\nfig.suptitle('title')            # big figure title\r\nfig.subplots_adjust(bottom=0.1, right=0.8, top=0.9, wspace=0.2,\r\n                    hspace=0.5)  # adjust subplot positions\r\nfig.tight_layout(pad=0.1,h_pad=0.5, w_pad=0.5, rect=None) # adjust\r\nsubplots to fit perfectly into fig\r\nax.set_xlabel()                  # set xlabel\r\nax.set_ylabel()                  # set ylabel\r\nax.set_xlim(1, 2)                # sets x limits\r\nax.set_ylim(3, 4)                # sets y limits\r\nax.set_title('blabla')           # sets the axis title\r\nax.set(xlabel='bla')             # set multiple parameters at once\r\nax.legend(loc='upper center')    # activate legend\r\nax.grid(True, which='both')      # activate grid\r\nbbox = ax.get_position()         # returns the axes bounding box\r\nbbox.x0 + bbox.width             # bounding box parameters\r\n```\r\n\r\n### plotting routines\r\n\r\n```python\r\nax.plot(x,y, '-o', c='red', lw=2, label='bla')  # plots a line\r\nax.scatter(x,y, s=20, c=color)                  # scatter plot\r\nax.pcolormesh(xx,yy,zz, shading='gouraud')      # fast colormesh function\r\nax.colormesh(xx,yy,zz, norm=norm)               # slower colormesh function\r\nax.contour(xx,yy,zz, cmap='jet')                # contour line plot\r\nax.contourf(xx,yy,zz, vmin=2, vmax=4)           # filled contours plot\r\nn, bins, patch = ax.hist(x, 50)                 # histogram\r\nax.imshow(matrix, origin='lower', extent=(x1, x2, y1, y2))  # show image\r\nax.specgram(y, FS=0.1, noverlap=128, scale='linear')  # plot a spectrogram\r\n```",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}